#!/bin/bash
#===============================================================================
# Yaml module for yane
#===============================================================================

#-------------------------------------------------------------------------------
# Parse a YAML config file. Thanks to
# https://gist.github.com/DinoChiesa/3e3c3866b51290f31243a
# (could be replaced with the following)
# http://stackoverflow.com/questions/5014632/how-can-i-parse-a-yaml-file-from-a-linux-shell-script
#-------------------------------------------------------------------------------
parse_yaml() {
    local prefix=$2
    local s
    local w
    local fs
    s='[[:space:]]*'
    w='[a-zA-Z0-9_]*'
    fs="$(echo @|tr @ '\034')"
    sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
	-e "s|^\($s\)\($w\)$s[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" "$1" |awk -F"$fs" '{
      indent = length($1)/2;
      if (length($2) == 0) { conj[indent]="+";} else {conj[indent]="";}
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
              vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
              printf("%s%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, conj[indent-1],$3);
      }
    }' | sed 's/_=/+=/g'
}

parse_yaml_1() {
    local prefix=$2
    local s
    local w
    local fs
    s='[[:space:]]*'
    w='[a-zA-Z0-9_]*'
    fs="$(echo @|tr @ '\034')"
    sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
	-e "s|^\($s\)\($w\)$s[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" "$1" |awk -F"$fs" '{
    depth=length($1)/2;
    name[depth]=$2
    if (depth == 1) {
       nb=0;
    } else if ((depth == 2)&& (length($2)==0)) {
       name[2]=nb++;
    }
    if ((0 == 0)) {
	val=$3;
	if (depth < 2) {
            vn=""; for (i=0; i<depth; i++) {vn=(vn)(name[i])("_")}
	    vn=(vn)(name[depth]);
	}else if (depth == 2){
	    vn=(name[0])("_")(name[1])("[")(name[2])("]");
	    if (length($3) ==0){val=name[2];}
	}else{
	    vn=(name[0])("_")(name[1])("_")(name[3])("[")(name[2])("]")
	}
        if (length(val) >0) {printf("%s=\"%s\"\n", vn, val);}
    }
  }'
}

function parse_yaml_2 {
    local prefix=$2
    local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
    sed -ne "s|^\($s\):|\1|" \
	-e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
	-e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
	   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
      }
   }'
}

#-------------------------------------------------------------------------------
# Read network configuration and build network variables.
#
# This function won't run anything. It will build the following variables
#
# hostNum      array (name indexed) of host number
# hostName     array (name indexed) of host name (a bit useless !)
# hostMode     array (name indexed) of host mode
# hostFiles    array (name indexed) of host files
# p2plinks     array of point to point links
# console_mode     array of host name to run console
#
# bridgeName            array (name indexed) of BridgeName
# bridgeInterfaces      array (name indexed) of BridgeInterface
#
#-------------------------------------------------------------------------------
buildNetworkFromFile_yaml () {
   logMessage LOG "Parsing file $1"
    
   # Parse the config file
   eval $(parse_yaml_1 $1) 2> /dev/null

   # First, yane configuration
   VERBOSE=${yane_verbose}

#   for hi in ${!network_hosts[@]}
#   do
#         network_hosts__name[$hi]="${network_hosts[$hi]}"
#   done
     
   # Build the host lists
#   for idx in ${!network_hosts__name[@]}
   for idx in ${!network_hosts[@]}
   do
      # Set the name
#      HNAME="${network_hosts__name[$idx]}"
      if [ -n "${network_hosts_name[$idx]}" ] ; then
         HNAME="${network_hosts_name[$idx]}"
      else
         HNAME="${network_hosts[$idx]}"
      fi
      
      hostName["$HNAME"]=$HNAME   # a bit useless, I know
      hostNum["$HNAME"]=$idx

      # If the mode is undefined, we fallback to the default one
#      if [ -n "${network_hosts__mode[$idx]}" -a "${network_hosts__mode[$idx]}" != "default" ] ; then
      if [ -n "${network_hosts_mode[$idx]}" -a "${network_hosts_mode[$idx]}" != "default" ] ; then
#        HMODE=${network_hosts__mode[$idx]}
        HMODE=${network_hosts_mode[$idx]}
      else
#        HMODE=${hosts_default__mode}
        HMODE=${hosts_default_mode}
      fi
      hostMode["$HNAME"]=$HMODE
      
      # If image is undefined, use the mode's default
#      if [ -n "${network_hosts__image[$idx]}" -a  "${network_hosts__image[$idx]}" != "default" ] ; then
#	  HIMAGE="${network_hosts__image[$idx]}"
#      else
#	  HIMAGE==$(eval echo "\$${HMODE}_default__image")
#      fi
      if [ -n "${network_hosts_image[$idx]}" -a  "${network_hosts_image[$idx]}" != "default" ] ; then
	  HIMAGE="${network_hosts_image[$idx]}"
      else
	  HIMAGE=$(eval echo "\$${HMODE}_default_image")
      fi
      
      hostImage["$HNAME"]=$HIMAGE
      
      # If files is undefined, we use the files parameter of host mode
#      if [ -n "${network_hosts__files[$idx]}" ] ; then
#	  HFILES=${network_hosts__files[$idx]}
      if [ -n "${network_hosts_files[$idx]}" ] ; then
	  HFILES=${network_hosts_files[$idx]}
      else
#          MFILES=$(eval echo "\$${HMODE}_default__files")
          MFILES=$(eval echo "\$${HMODE}_default_files")
	  if [ -n "$MFILES" ] ; then
	      HFILES="$MFILES"
	  fi
      fi
      # Substituting name in files
      if  [ -n "$HFILES" ] ; then
	  HFILES=${HFILES//"%n"/${HNAME}}
#	  hostFiles["${network_hosts__name[$idx]}"]=$HFILES
	  hostFiles["$HNAME"]=$HFILES
      fi

      logMessage LOG "Host '$HNAME' mode '$HMODE' image '$HIMAGE'"
      logMessage LOG "  Files '$HFILES'"
   done

   #Build the services lists
   for idx in ${!network_services__name[@]}
   do
     serviceName[${network_services__name[$idx]}]=${network_services__name[$idx]}
	   serviceType[${network_services__name[$idx]}]=${network_services__type[$idx]}
	   serviceConfig[${network_services__name[$idx]}]=${network_services__config[$idx]}
   done

   # Build the console list
   if [ "$network_consoles" == "all" ] ; then
      for idx in ${hostName[@]}
      do
         console_mode[$idx]="xterm"
      done
   else
      ids=0
      for idx in ${!network_consoles__host[@]}
      do
         if [ "${hostName[${network_consoles__host[$idx]}]}" == "${network_consoles__host[$idx]}" ]  ; then
             console_mode[${network_consoles__host[$idx]}]=${network_consoles__mode[$idx]}
             if [ ${network_consoles__mode[$idx]} == "tmux" ]; then
                 console_session_tmux[${network_consoles__host[$idx]}]=${network_consoles__session[$ids]}
                 (( ids++ ))
             fi
         else
             logMessage ERR "Cannot open console on unknown host '$idx' ..."
         fi
      done
   fi

   # Build the p2pLinks list
   for idx in ${network_links[@]}
   do
      p2pLinks[$idx]=$idx
   done

   # Build the bridges related lists
#   for idx in ${!network_bridges__name[@]}
   for idx in ${!network_bridges[@]}
   do
#      br=${network_bridges__name[idx]}
      if [ -n "${network_bridges_name[$idx]}" ] ; then
         BNAME="${network_bridges_name[$idx]}"
      else
         BNAME="${network_bridges[$idx]}"
      fi
#      bridgeName[$br]="${network_bridges__name[$idx]}"
      bridgeName[$BNAME]="$BNAME"
#      bridgeInterfaces[$br]="${network_bridges__interfaces[$idx]}"
      bridgeInterfaces[$BNAME]="${network_bridges_interfaces[$idx]}"
      logMessage DEB "$idx -> $BNAME  ${bridgeInterfaces[$BNAME]}"
   done

   # Build the dumpif list
   for idx in ${network_dumpif[@]}
   do
      hn=`echo $idx| cut -d: -f1`
      if [ "${hostName[$hn]}" == "$hn" -o "$idx" == "all" ]  ; then
          dumpIf[$idx]=$idx
      else
          logMessage ERR "Cannot snoop on unknown host '$hn' ..."
      fi
   done

}
