#!/bin/bash
#-------------------------------------------------------------------------------
#  yane (Yet Another Network Emulator !) by E. Chaput
#
#    0.1   : - put it on github
#    0.2   : - bridges
#
#  TBD
#    0.2.1 : - introduce session (so that yane -k can kill the
#            current (or any) session : remove netns, ...
#    0.3   : - another virt tool
#            - remove WARNINGs (namespace specific parts)
#    ???   : - Doc
#            - install procedure
#-------------------------------------------------------------------------------
#YANE_VERSION="0.1"     # First test
#YANE_VERSION="0.1.1"   # Minor bug correction
YANE_VERSION="0.2"      # Introducing bridges

#-------------------------------------------------------------------------------
# Main commands (do not trust $PATH)
#-------------------------------------------------------------------------------
BASH=/bin/bash
BASENAME=/usr/bin/basename
CAT=/bin/cat
DIRNAME=/usr/bin/dirname
GREP=/bin/grep
IP=/sbin/ip
KILL=/bin/kill
LS=/bin/ls
MKFIFO=/usr/bin/mkfifo
MKDIR=/bin/mkdir
RM=/bin/rm
READLINK=/bin/readlink
TOUCH=/usr/bin/touch
TRUE=/bin/true
XTERM=/usr/bin/xterm

#-------------------------------------------------------------------------------
# Main parameters
#-------------------------------------------------------------------------------
YANE_ROOT_DIR=$($DIRNAME $($READLINK -f $0))
BASEDIR=$PWD
DEBUG=False
VERBOSE=False
NET_CONFIG_FILE=yane.yml
TMP_CFG_FILE=./yane.$$
YANE_DEFAULT_NETNS=yans-$$

#-------------------------------------------------------------------------------
# Some variables
#-------------------------------------------------------------------------------
declare -A hostNum       # Array of host numbers : 0 1, ...
declare -A hostName      # Array of host names
declare -A hostMode      # Array of host mode
declare -A consHost      # Array of hosts to run console on
declare -A p2pLinks      # Array of p2p links
declare -A interfaces    # Array of known interfaces
declare -A dumpIf        # Array of interface to snoop
declare -A modules       # Array o loaded modules

FIFO_ROOT=/tmp/nssi
TCPDUMP_PID_FILE=./.tcpdump-pids

#===============================================================================
# General helper functions
#===============================================================================

#-------------------------------------------------------------------------------
# Cleanup before exit
#-------------------------------------------------------------------------------
cleanup () {
   $RM $TMP_CFG_FILE > /dev/null 2>&1 || $TRUE
}

#-------------------------------------------------------------------------------
# Basic log utility
#   $1 : LOG (printed iif VERBOSE) ERR DEB (print iif DEBUG)
#   $2 : message
#-------------------------------------------------------------------------------
logMessage () {
   case "$1" in 
      ERR )
         shift
         echo $*
      ;;
      LOG )
         shift
         if [ "$VERBOSE" == "True" ] ; then 
            echo $*
         fi
      ;;
      DEB )
         shift
         if [ "$DEBUG" == "True" ] ; then 
            echo $*
         fi
      ;;
   esac
}

exitYane () {
   cleanup
   exit
}

#-------------------------------------------------------------------------------
# Display hosts
#-------------------------------------------------------------------------------
yaneDisplayHosts () {
   for hn in ${network_hosts__name[@]}
   do
      echo "[${hostNum[$hn]}]  $hn mode ${hostMode[$hn]}"
   done
}

#-------------------------------------------------------------------------------
# Have we created host $1 ?
#-------------------------------------------------------------------------------
yaneHostExists() {
   if [ "${hostName["$1"]}" != "$1" ] ; then
      return 1
   fi
   return $(yaneHostExists_${hostMode["$1"]} "$1")
}

yaneHostUnknown() {
   if $(yaneHostExists "$1") ; then
      return 1
   else
      return 0
   fi
}

#-------------------------------------------------------------------------------
# Can $1 host a new $2 interface ?
#-------------------------------------------------------------------------------
yaneDeviceCanHostInterface() {
   # First check : is this interface a new one ?
   if [ ""${interfaces["$1:$2"]} == "$1:$2" ] ; then
      return 1
   fi

   # If $1 is an host
   if $(yaneHostExists "$1") ; then
      # WARNING : should check for $2
      return 0
   fi
   
   # If $1 is a bridge
   if $(yaneBridgeExists "$1") ; then
      # WARNING : should check for $2
      return 0
   fi
    
   return 1
}

#-------------------------------------------------------------------------------
#   Display network elements (debug purpose)
#-------------------------------------------------------------------------------
yaneDisplayNetwork () {
   echo "Hosts : "
   yaneDisplayHosts

   echo "Bridges : "
   for idx in ${!bridgeName[@]} ; do
      br=${bridgeName[$idx]} 
      echo "   . [$idx] '$br'"
      il=${bridgeInterfaces["$br"]}
      echo "       Interfaces : '$il'"
   done
}

#-------------------------------------------------------------------------------
# Loading modules
#-------------------------------------------------------------------------------
yaneLoadModules() {
   mods=`$LS $YANE_ROOT_DIR/yane_module_*|$GREP -v \~`

   for mod in $mods
   do
      logMessage DEB "Loading $mod"
      . $mod
      modules+="`$BASENAME $mod` "
   done
}

#===============================================================================
# Snooping helper functions
#
# Run a tcpdump on each if in dumpIf. The output is sent to a fifo.
# WARNING : namespace specific
#===============================================================================
yaneStartSnooping () {
    dumpFifo=""
    $RM -rf $FIFO_ROOT > /dev/null 2>&1 ||$TRUE
    $MKDIR $FIFO_ROOT > /dev/null 2>&1 ||$TRUE
    $RM $TCPDUMP_PID_FILE > /dev/null 2>&1 ||$TRUE

    if [ "${dumpIf['all']}" == "all" ] ; then
       unset dumpIf["all"]
       for i in ${interfaces[@]} ; do
          h=`echo $i| cut -d: -f1`
          if [ "${hostName[$h]}" == "$h" ] ; then 
             dumpIf["$i"]="$i"
          fi
       done
    fi

    for dif in ${dumpIf[@]} ; do
       h=`echo $dif|cut -d: -f1`
       i=`echo $dif|cut -d: -f2`
       logMessage LOG "Snooping on int '$i' from '$h'"

       if [ -z ""$h ] ; then
	   logMessage ERR "No snoop host defined in '$dif'"
	   exit
       fi
       if [ -z ""`$IP netns list|grep $h` ] ; then
	   logMessage ERR "Unknown snoop host '$h'"
	   exit
       fi
       if [ -z ""$i ] ; then
	   logMessage ERR "No snoop interface defined in '$snoopi'"
	   exit
       fi

       $MKDIR $FIFO_ROOT/$h > /dev/null 2>&1 ||$TRUE
       $MKFIFO $FIFO_ROOT/$h/$i
       
       $IP netns exec $h $YANE_ROOT_DIR/yane_run_tcpdump $i $FIFO_ROOT/$h/$i > /dev/null 2>&1 & 
       echo $! >> $TCPDUMP_PID_FILE
    done

   if [ ${#dumpIf[@]} -gt 0 ] ; then
      echo You could run
      echo -n "wireshark "
      for dif in ${dumpIf[@]} ; do
          h=`echo $dif|cut -d: -f1`
          i=`echo $dif|cut -d: -f2`
	  echo -n "-i $FIFO_ROOT/$h/$i "
      done
      echo
   fi
}

#-------------------------------------------------------------------------------
# Kill all open consoles
#-------------------------------------------------------------------------------
yaneKillSnooping () {
   logMessage LOG "Kill snooping"
   
   if [ -f ./.yane_snooping.pid ] ; then 
      for c in `cat ./.yane_snooping.pid`
      do
          $KILL $c
      done
      $RM ./.yane_snooping.pid
   fi
}


#===============================================================================

#-------------------------------------------------------------------------------
# Run the startup script
#-------------------------------------------------------------------------------
runStartupScript () {
   if [ -n "$network_startup" -a  -f "$network_startup" ] ; then
      logMessage LOG "Running startup script '"$network_startup"' ..."	
      . $network_startup
   fi
}

#-------------------------------------------------------------------------------
# Create hosts based on
#   hostNum
#   hostName
#   hostMode
#-------------------------------------------------------------------------------
createHosts () {
   for hn in ${hostName[@]}
   do
      createHost_${hostMode[$hn]} $hn
   done      
}

#-------------------------------------------------------------------------------
# Kill hosts based on
#   hostNum
#   hostName
#   hostMode
#-------------------------------------------------------------------------------
killHosts () {
   for hn in ${hostName[@]}
   do
      killHost_${hostMode[$hn]} $hn
   done      
}

#-------------------------------------------------------------------------------
# Add an interface to the list
#   $1 : host
#   $2 : interface
#-------------------------------------------------------------------------------
yaneAddInterface () {
   if [ ""${interfaces["$1:$2"]} == "$1:$2" ] ; then
      logMessage  ERR "Interface $1:$2 already defined !"
      exitYane
   fi
   
   interfaces["$1:$2"]="$1:$2"
}

#-------------------------------------------------------------------------------
# Create a p2p link
# Format h:i[:@]!h:i[:@]
# 
#-------------------------------------------------------------------------------
createLink () {
   l=$1
   logMessage LOG Creating link $l

   src=`echo $l| cut -d! -f1`
   srch=`echo $src|cut -d: -f1`
   if [ -z ""$srch ] ; then
      logMessage ERR "No source host defined in '$l'"
      exit
   fi
   srci=`echo $src|cut -d: -f2`
   if [ -z ""$srci ] ; then
      logMessage ERR "No source interface defined in '$l'"
      exit
   fi
   # WARNING : first check $srch type
   if $(yaneDeviceCanHostInterface "$srch" "$srci") ; then
      logMessage DEB "Source device '$srch' found"
   else
      logMessage ERR "Source device '$srch' can not accept interface '$srci'"
      exit
   fi
   IFLIST="$IFLIST $srch:$srci"
   srca=`echo $src|cut -d: -f3`
   dst=`echo $l| cut -d! -f2`
   dsth=`echo $dst|cut -d: -f1`
   if [ -z ""$dsth ] ; then
      logMessage ERR "No destination host defined in '$l'"
      exit
   fi
   dsti=`echo $dst|cut -d: -f2`
   if [ -z ""$dsti ] ; then
      logMessage ERR "No destination interface defined in '$l'"
      exit
   fi
   if $(yaneDeviceCanHostInterface "$dsth" "$dsti") ; then
      logMessage DEB "Destination device '$dsth' found"
   else
      logMessage ERR "Destination device '$dsth' can not accept interface '$dsti'"
      exit
   fi
   IFLIST="$IFLIST $dsth:$dsti"
   dsta=`echo $dst|cut -d: -f3`
   logMessage LOG "  . $srch ($srci)  <-> $dsth ($dsti)"
   if [ -n ""$srca ] ; then
      logMessage LOG "    $srch : $srca"
   fi   
   if [ -n ""$dsta ] ; then
      logMessage LOG "    $dsth : $dsta"
   fi

   # Register interfaces
   yaneAddInterface $srch $srci
   yaneAddInterface $dsth $dsti

    # We create temporary namespaces
   $IP netns del yane-src-$$ > /dev/null 2>&1
   $IP netns del yane-dst-$$ > /dev/null 2>&1
   $IP netns add yane-src-$$ 
   $IP netns add yane-dst-$$
   
   # Interfaces creation
   $IP netns exec yane-src-$$ $IP link add $srci type veth peer name $dsti netns yane-dst-$$
    
   # Search for source host
   if [[ ${hostMode["$srch"]} ]] ; then
       logMessage DEB "source host found"
       yaneAddHostInterface_${hostMode[$srch]} $srch $srci "$srca" yane-src-$$
   fi
   # Search for destination host
   if [[ ${hostMode["$dsth"]} ]] ; then
      logMessage DEB "destination host found"
      yaneAddHostInterface_${hostMode[$dsth]} $dsth $dsti "$dsta" yane-dst-$$
   elif $(yaneBridgeExists $dsth) ; then
      logMessage DEB "destination bridge found"
      yaneAddBridgeInterface  $dsth $dsti "$dsta" yane-dst-$$
   fi
   
   # We can now delete transiant namespaces
   $IP netns del yane-src-$$ 
   $IP netns del yane-dst-$$
}

#-------------------------------------------------------------------------------
# Kill a p2p link
#-------------------------------------------------------------------------------
killLink () {
   logMessage ERR "killLink not yet implemented"
}

#-------------------------------------------------------------------------------
# Create p2p links
#-------------------------------------------------------------------------------
createLinks () {
   for link in ${p2pLinks[@]}
   do
      createLink "$link"
   done      
}

#-------------------------------------------------------------------------------
# Kill p2p links
#-------------------------------------------------------------------------------
killLinks () {
   for link in ${network_links[@]}
   do
      killLink "$link"
   done      
}

#-------------------------------------------------------------------------------
# Booting up the network
#-------------------------------------------------------------------------------
yaneRunNetwork () {
   logMessage LOG "Starting network"

   # Default namespace
   $IP netns add $YANE_DEFAULT_NETNS

   runStartupScript
   createHosts    
   createLinks
   yaneCreateBridges
   yaneStartSnooping
}

#-------------------------------------------------------------------------------
# Shutting down the network
#-------------------------------------------------------------------------------
killNetwork () {
   logMessage LOG "Shutting down network"

   yaneKillSnooping
   yaneKillConsoles
   killLinks
   killHosts

   # Delete default namespace
   $IP netns del $YANE_DEFAULT_NETNS
}

#-------------------------------------------------------------------------------
# Cleanup before exit
#-------------------------------------------------------------------------------
cleanup () {
   $RM $TMP_CFG_FILE > /dev/null 2>&1 || $TRUE
   $RM -rf $FIFO_ROOT > /dev/null 2>&1 ||$TRUE
   $RM $TCPDUMP_PID_FILE > /dev/null 2>&1 ||$TRUE
}

yaneLoadModules
#-------------------------------------------------------------------------------
# Parse command line options
#-------------------------------------------------------------------------------
while [[ $# > 0 ]] ;
do
   case "$1" in
      -c )
	 shift
         buildNetworkFromFile_yaml $NET_CONFIG_FILE
	 yaneOpenConsole "$1"
	 exitYane
      ;;
      -d )
          parse_yaml $NET_CONFIG_FILE
          DEBUG=True
	 ;;
      -f )
	 shift
         NET_CONFIG_FILE="$1"
      ;;
      -k )
         buildNetworkFromFile_yaml $NET_CONFIG_FILE
         killNetwork
	 exitYane
      ;;
      -l )
	  logMessage ERR "Root is $ROOTDIR"
	  exit
      ;;
      -n )
         PRETEND=TRUE
         VERBOSE=TRUE
	 echo Pretending
      ;;
      -p )
         buildNetworkFromFile_yaml $NET_CONFIG_FILE
         yaneDisplayNetwork
         exitYane
      ;;
      -v )
         VERBOSE=True
      ;;
      -h )
         $CAT << EOF
What ?
   Yet Another Netork Emulator !?

   Yes, by Manu Chaput. Version : $YANE_VERSION

Usage
   yane [-c] [-v] [-w]

Options
   -c <host>    open a terminal on host then exit
   -f <file>    use file as config
   -h           help
   -v           be verbose
   -w <host>    open a forked terminal in a window on host

Modules
   ${modules[@]}
EOF
	 exit
      ;;
      * )
	  echo Unknown option $1
      ;;
   esac
   shift
done


#-------------------------------------------------------------------------------
# Parse network config and run the network
#-------------------------------------------------------------------------------

buildNetworkFromFile_yaml $NET_CONFIG_FILE

yaneRunNetwork

yaneOpenConsoleWindows

exitYane
